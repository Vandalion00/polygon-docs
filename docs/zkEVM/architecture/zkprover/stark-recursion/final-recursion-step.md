This section focuses on the final step of the proof recursion, where the last but one _intermediate_ STARK proof, referred to as _recursivef_, is verified as well as the very last conversion of a STARK proof to a circuit.

## Setup S2C for recursivef

The idea here is the same as seen before when executing a _S2C_: It is to generate a CIRCOM circuit that verifies $\mathtt{\pi_{rec2}}$, by mimicking the FRI verification procedure.

In order to achieve this, a verifier circuit _recursive2.verifier.circom_ is generated from the previously obtained files;

- The _recursive2.pil_ file,
- The _recursive2.starkinfo_ file and
- The constant roots of the previous two proofs $\mathtt{recursive2\_} \texttt{a.verkey.constRoot}$ and $\mathtt{recursive2\_b.} \texttt{verkey.constRoot}$;

by filling the $\mathtt{stark\_} \texttt{verifier.circom.ejs}$ template.

The output CIRCOM file _recursivef.circom_, obtained by running a different script called _genrecursivef_, is in turn compiled into an R1CS _recursivef.r1cs_ file and a witness calculator program, _recursivef.witnesscal_.

Both these outputs are used later on, to build and fill the next execution trace.

![Figure 19: Convert the _recursive2_ STARK to its verifier circuit called _recursivef_.](../../../../img/zkEVM/19prf-rec-recursive2-stark-to-recursivef-circuit.png)

## Setup C2S for recursivef

A _C2S_ is again executed in this step. Hence a machine-like construction is obtained from the R1CS description of the verification circuit.

And, this construction must be the one whose execution correctness is equivalent to the validity of the previous circuit.

In this case, the R1CS description is in the file _recursivef.r1cs_, and the obtained construction is described by _recursivef.pil_.

Again, a binary for all the constant polynomials _recursivef.const_ is generated, together with the helper file _recursivef.exec_, which provides allocation of the witness values into their corresponding positions in the execution trace.

Since all FRI-related parameters are stored in a _recursive.starkstruct_ file, and this file is coupled with,

- the _recursivef.pil_ file as inputs to the $\mathtt{generate\_starkinfo}$ service in order to generate the _recursivef.starkinfo_ file, and
- the _recursivef.const_ as inputs to the component that builds the Merkle tree of evaluations of constant polynomials, _recursivef.consttree_, and its root _recursivef.verkey_.

![Figure 20: Convert the _recursivef_ circuit to its associated STARK.](../../../../img/zkEVM/20prf-rec-recursivef-circuit-2-stark.png)

## Setup S2C for final

As done previously when executing a _S2C_, a CIRCOM circuit that verifies $\mathtt{\pi_ {recf}}$ is generated by mimicking the FRI verification procedure.

In order to achieve this, a verifier circuit _recursivef.verifier.circom_ is generated from the previously obtained files;

- The _recursivef.pil_ file,
- The _recursivef.starkinfo_ file and
- The constant roots of the previous two proofs $\mathtt{recursivef\_} \texttt{a.verkey.constRoot}$ and $\mathtt{recursivef\_b.} \texttt{verkey.constRoot}$,

by filling the $\mathtt{stark\_} \texttt{verifier.circom.ejs}$ template.

This verifier CIRCOM file gets imported by the _final.circom_ circuit in order to generate the circuit being proved, using _FFLONK_ procedure.

![Convert the _recursivef_ STARK to its verifier circuit called _final.circom}$.](../../../../img/zkEVM/21prf-rec-recursivef-stark-to-final-circom.png)
