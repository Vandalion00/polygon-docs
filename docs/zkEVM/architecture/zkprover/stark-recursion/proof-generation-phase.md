This document explains the proof generation phase for all proofs; the zkEVM STARK, the compression _c12a_ step, the recursion proof _recursion1_, the intermediate recursion proof _recursion2_ and the final recursion proof _recursionf_.

## Proof of the zkEVM STARK

The execution trace has up to this point been built, together with a PIL file describing the ROM of the zkEVM. 

Given these two, a STARK proof which attests to the correct execution of the zkEVM, can be generated using the PIL-STARK tooling explained [here](../../../concepts/mfibonacci/pil-stark.md).

In this step, a blowup factor of 2 is used, so the proof becomes quite big due to a huge amount of polynomials.

The compression step _c12a_ was added for this very reason, raising the blowup factor and thus reducing the number of polynomials.

![Generation for a zkEVM Proof.](../../../../img/zkEVM/22prf-rec-generation-stark-proof-for-recursivef.png)

In order to generate the proof, the $\mathtt{main\_prover}$ service is used, and requires as input;

- The execution trace (that is, the committed and constant polynomials files generated by the executor using the PILCOM package),
- The constant tree binary file in order to be hashed to compute the constant root,
- The PIL file of the $\text{zkEVM ROM}$, _zkevm.pil_,
- All the information provided by the _zkevm.starkinfo.json_ file,

including all the FRI-related parameters such as the blowup factor or the configuration of the steps.

This step is intended to start the recursion, and therefore differs from the subsequent ones. However, aiming at uniformity of the code, the Main Prover procedure chooses to abstract the notion of proving. And it is intended to be the same at each step of the recursion.

### Proof of c12a

In order to generate the proof verifying the previous _zkevm.proof_, all the witness values can be generated and mapped correctly into its corresponding position of the execution trace in the same exact manner as before, obtaining a binary file _c12a.commit_ for the committed polynomials of the execution trace.

Having the execution trace (that is, the committed and constant polynomials filled) and the PIL, a proof validating the previous big STARK proof can be generated.

The same $\mathtt{main\_prover}$ service used earlier is again used here, and as before it takes as input the previously built constant tree _c12a.constTree_ and the _c12a.starkinfo_ file.

It in turn generates the proof _c12a.proof_ and the publics _c12a.public_ combined in the _c12a.zkin.proof_ file.

![Generate a STARK proof for c12a.](../../../../img/zkEVM/23prf-rec-generation-stark-proof-for-c12.png)

### Proof of recursive1

In order to generate the proof that verifies the previous _c12a.proof_, all the witness values are generated and mapped correctly into their corresponding positions of the execution trace in the exact same way as before, obtaining a binary file _recursive1.commit_ for the committed polynomials of the execution trace.

Having the execution trace (that is, the committed and constant polynomials filled) and the PIL, a proof validating the previous big STARK proof can be generated.

The same $\mathtt{main\_prover}$ service used previously is applied again here, it again takes as input the previously built constant tree _recursive1.constTree_ and the _recursive1.starkinfo_ file.

This generates the proof and the publics included in the _recursive1.zkin.proof_ file.

![Generate a STARK proof for recursive1.](../../../../img/zkEVM/24prf-rec-generation-stark-proof-for-recursive1.png)

### Proof of recursive2

To generate the proof verifying the previous _recursive1.proof_, all witness values must be generated and mapped correctly into their corresponding positions of the execution trace in the exact same way as before, obtaining a binary file _recursive2.commit_ for the committed polynomials of the execution trace.

Having the execution trace (that is, the committed and constant polynomials filled) and the PIL, a proof validating the previous big STARK proof can generated.

The same service $\mathtt{main\_prover}$ generates this proof, as it was done before, it takes as inputs the previously built constant tree _recursive2.constTree_ and the _recursive2.starkinfo_ file.

This generate the proof and the publics combined in the _recursive2.zkin.proof_ file.

![Generate a STARK proof for recursive2.](../../../../img/zkEVM/25prf-rec-generation-stark-proof-for-recursive2.png)

### Proof of recursivef

To generate the proof verifying the previous _recursive2.proof_, we generate all the witness values and map them correctly into its corresponding position of the execution trace exactly in the same way as before, obtaining a binary file _recursivef.commit_ for the committed polynomials of the execution trace.

Having the execution trace (that is, the committed and constant polynomials filled) and the PIL, we can generate a proof validating the previous big STARK proof.

Again, the same $\mathtt{main\_prover}$ service is used to generate the proof. As before, it takes as inputs the previously built constant tree $\mathtt{recursivef.constTree}$ and the $\mathtt{recursivef.starkinfo}$ file.

This generates the proof and the publics included in the _recursivef.zkin.proof_ file.

![Generate a STARK proof for recursivef.](../../../../img/zkEVM/26prf-rec-generation-zkevm-proof.png)

### Proof of the final Stage

The last circuit, _final.circom_ is the one used to generate the proof. At this moment a FFLONK proof is generated.

## Remarks

The setup phase runs with the proverjs. The proof generation runs with the prover written in $\text{C}$. The circuits build in the setup phase can be used as many times as desired. The prover receives the information about the particular composition of proofs with an $\text{RPC}$ $\text{API}$.
